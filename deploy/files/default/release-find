#!/usr/bin/env node
var util = require('util');
var async = require('async');
var fs = require('fs');
var mongoose = require('mongoose');
var models = require('./models');

var clientPrefix = 'CLIENT_';
var indexPrefix = 'INDEX_';

var certPath = process.env.CERT_SERANDIVES;
var pemPath = process.env.PEM_SERVER;
var mongourl = process.env.MONGODB_URI;

var ca = certPath ? fs.readFileSync(certPath) : null;
var pem = pemPath ? fs.readFileSync(pemPath) : null;

mongoose.connect(mongourl, {
    useMongoClient: true,
    authSource: 'admin',
    ssl: !!pem,
    sslCA: ca,
    sslCert: pem,
    sslKey: pem
});

var find = function (name, done) {
    models.Release.find({
        type: 'serandomps',
        name: name
    }).limit(1).sort({_id: -1}).exec(function (err, releases) {
        if (err) {
            return done(err);
        }
        if (!releases.length) {
            return done(new Error(util.format('cannot find a release for client: %s', name)));
        }
        var release = releases[0];
        done(null, util.format('export %s%s=%s', indexPrefix, release.name.toUpperCase(), release.version));
    });
};

var code = [];

async.each(Object.keys(process.env), function (name, found) {
    if (name.indexOf(clientPrefix) !== 0) {
        return found();
    }
    var version = process.env[name];
    if (version !== 'master') {
        return found();
    }
    var client = name.substring(clientPrefix.length).toLowerCase();
    find(client, function (err, release) {
        if (err) {
            return found(err);
        }
        code.push(release);
        found();
    });
}, function (err) {
    if (err) {
        console.error(err);
        return process.exit(1);
    }
    console.log(code.join('\\n'));
    process.exit(0);
});